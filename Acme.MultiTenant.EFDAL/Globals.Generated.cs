//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.Serialization;
using System.Collections.Concurrent;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel;

namespace Acme.MultiTenant.EFDAL
{
	/// <summary />
	public partial interface IMetadata
	{
		/// <summary>
		/// Gets the underlying table name.
		/// </summary>
		string GetTableName();

		/// <summary>
		/// Gets a list of all object fields with alias/code facade applied excluding inheritance.
		/// </summary>
		List<string> GetFields();

		/// <summary>
		/// Returns the type of the parent object if one exists.
		/// </summary>
		System.Type InheritsFrom();

		/// <summary>
		/// Returns the database schema name.
		/// </summary>
		string Schema();

		/// <summary>
		/// Returns the actual database name of the specified field.
		/// </summary>
		string GetDatabaseFieldName(string field);
	}

	#region GlobalValues

	internal static class GlobalValues
	{
		public const string ERROR_PROPERTY_NULL = "The value is null and in an invalid state.";
		public const string ERROR_PROPERTY_SETNULL = "Cannot set value to null.";
		public const string ERROR_CONCURRENCY_FAILURE = "Concurrency failure";
		public const string ERROR_CONSTRAINT_FAILURE = "Constraint failure";
		public const string ERROR_DATA_TOO_BIG = "The data '{0}' is too large for the {1} field which has a length of {2}.";
		public const string ERROR_INVALID_ENUM = "The value '{0}' set to the '{1}' field is not valid based on the backing enumeration.";
		public static readonly DateTime MIN_DATETIME = new DateTime(1753, 1, 1);
		public static readonly DateTime MAX_DATETIME = new DateTime(9999, 12, 31, 23, 59, 59);
		private const string INVALID_BUSINIESSOBJECT = "An invalid object of type 'IBusinessObject' was passed in. Perhaps a relationship was not enforced correctly.";

		internal static string SetValueHelperInternal(string newValue, bool fixLength, int maxDataLength)
		{
			string retval = null;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				var v = newValue.ToString();
				if (fixLength)
				{
					int fieldLength = maxDataLength;
					if ((fieldLength > 0) && (v.Length > fieldLength)) v = v.Substring(0, fieldLength);
				}
				retval = v;
			}
			return retval;
		}

		internal static double? SetValueHelperDoubleNullableInternal(object newValue)
		{
			double? retval;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				if (newValue is string)
				{
					retval = double.Parse((string)newValue);
				}
				else if (!(newValue is double?))
				{
					retval = double.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (double?)newValue;
			}
			return retval;
		}

		internal static double SetValueHelperDoubleNotNullableInternal(object newValue, string nullMessage)
		{
			double retval;
			if (newValue == null)
			{
				throw new Exception(nullMessage);
			}
			else
			{
				if (newValue is string)
				{
					retval = double.Parse((string)newValue);
				}
				else if (!(newValue is double))
				{
					retval = double.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (double)newValue;
			}
			return retval;
		}

		internal static DateTime? SetValueHelperDateTimeNullableInternal(object newValue)
		{
			DateTime? retval;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				if (newValue is string)
				{
					retval = DateTime.Parse((string)newValue);
				}
				else if (!(newValue is DateTime?))
				{
					retval = DateTime.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (DateTime?)newValue;
			}
			return retval;
		}

		internal static DateTime SetValueHelperDateTimeNotNullableInternal(object newValue, string nullMessage)
		{
			DateTime retval;
			if (newValue == null)
			{
				throw new Exception(nullMessage);
			}
			else
			{
				if (newValue is string)
				{
					retval = DateTime.Parse((string)newValue);
				}
				else if (!(newValue is DateTime))
				{
					retval = DateTime.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (DateTime)newValue;
			}
			return retval;
		}

		internal static bool? SetValueHelperBoolNullableInternal(object newValue)
		{
			bool? retval;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				if (newValue is string)
				{
					retval = bool.Parse((string)newValue);
				}
				else if (!(newValue is bool?))
				{
					retval = bool.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (bool?)newValue;
			}
			return retval;
		}

		internal static bool SetValueHelperBoolNotNullableInternal(object newValue, string nullMessage)
		{
			bool retval;
			if (newValue == null)
			{
				throw new Exception(nullMessage);
			}
			else
			{
				if (newValue is string)
				{
					retval = bool.Parse((string)newValue);
				}
				else if (!(newValue is bool))
				{
					retval = bool.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (bool)newValue;
			}
			return retval;
		}

		internal static int? SetValueHelperIntNullableInternal(object newValue)
		{
			int? retval;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				if (newValue is string)
				{
					retval = int.Parse((string)newValue);
				}
				else if (!(newValue is int?))
				{
					retval = int.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (int?)newValue;
			}
			return retval;
		}

		internal static int SetValueHelperIntNotNullableInternal(object newValue, string nullMessage)
		{
			int retval;
			if (newValue == null)
			{
				throw new Exception(nullMessage);
			}
			else
			{
				if (newValue is string)
				{
					retval = int.Parse((string)newValue);
				}
				else if (!(newValue is int))
				{
					retval = int.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (int)newValue;
			}
			return retval;
		}

		internal static long? SetValueHelperLongNullableInternal(object newValue)
		{
			long? retval;
			if (newValue == null)
			{
				retval = null;
			}
			else
			{
				if (newValue is string)
				{
					retval = long.Parse((string)newValue);
				}
				else if (!(newValue is long?))
				{
					retval = long.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (long?)newValue;
			}
			return retval;
		}

		internal static long SetValueHelperLongNotNullableInternal(object newValue, string nullMessage)
		{
			long retval;
			if (newValue == null)
			{
				throw new Exception(nullMessage);
			}
			else
			{
				if (newValue is string)
				{
					retval = long.Parse((string)newValue);
				}
				else if (!(newValue is long))
				{
					retval = long.Parse(newValue.ToString());
				}
				else if (newValue is IBusinessObject)
				{
					throw new Exception(INVALID_BUSINIESSOBJECT);
				}
				else
					retval = (long)newValue;
			}
			return retval;
		}

		internal static T PropertyGetterLambdaErrorHandler<T>(Func<T> func)
		{
			try
			{
				return func();
			}
			catch (Exception ex) { System.Diagnostics.Debug.WriteLine(ex.ToString()); throw; }
		}

		internal static void PropertySetterLambdaErrorHandler(System.Action action)
		{
			try
			{
				action();
			}
			catch (Exception ex) { System.Diagnostics.Debug.WriteLine(ex.ToString()); throw; }
		}

	}

	#endregion

	#region Util
	internal static partial class Util
	{
		public static string HashPK(params object[] p)
		{
			var retval = string.Empty;
			for (var ii = 0; ii < p.Length; ii++)
			{
				retval += p[ii] + "|" + ii + "|";
			}
			return retval;
		}

		public static UInt64 HashFast(string read)
		{
			UInt64 hashedValue = 3074457345618258791ul;
			for (int i = 0; i < read.Length; i++)
			{
				hashedValue += read[i];
				hashedValue *= 3074457345618258799ul;
			}
			return hashedValue;
		}

		internal static string StripEFCS2Normal(string connectionString)
		{
			const string PROVIDER = "provider connection string";
			if (connectionString.StartsWith("metadata="))
			{
				var retval = string.Empty;
				var index = connectionString.IndexOf(PROVIDER);

				var index1 = -1;
				var index2 = -1;
				if (index == -1) return connectionString;

				var foundEQ = false;
				for (var ii = index + PROVIDER.Length; ii < connectionString.Length; ii++)
				{
					if (connectionString[ii] == '=')
					{
						foundEQ = true;
					}
					else if (foundEQ)
					{
						connectionString = connectionString.Substring(ii, connectionString.Length - ii);
						index1 = connectionString.IndexOf('"');
						index2 = connectionString.LastIndexOf('"');
					}

					if (index1 != -1 && index2 != -1)
					{
						return connectionString.Substring(index1 + 1, index2 - index1 - 1);
					}

				}

			}
			return connectionString;
		}

	}
	#endregion

	#region AuditTypeConstants Enumeration

	/// <summary>
	/// A set of values for the types of audits
	/// </summary>
	public enum AuditTypeConstants
	{
		/// <summary>
		/// Represents a row insert
		/// </summary>
		Insert = 1,
		/// <summary>
		/// Represents a row update
		/// </summary>
		Update = 2,
		/// <summary>
		/// Represents a row delete
		/// </summary>
		Delete = 3,
	}

	#endregion

	#region IAudit
	/// <summary>
	/// The base interface for all audit objects
	/// </summary>
	public interface IAudit
	{
		/// <summary>
		/// The type of audit
		/// </summary>
		AuditTypeConstants AuditType { get; }

		/// <summary>
		/// The date of the audit
		/// </summary>
		DateTime AuditDate { get; }

		/// <summary>
		/// The modifier value of the audit
		/// </summary>
		string ModifiedBy { get; }
	}
	#endregion

	#region ICreatable
	/// <summary />
	public partial interface ICreatable
	{
	}
	#endregion

	#region IAuditable
	/// <summary />
	internal partial interface IAuditableSet
	{
		DateTime CreatedDate { set; }
		DateTime ModifiedDate { set; }
		string ModifiedBy { set; }
		string CreatedBy { set; }
	}

	/// <summary />
	public partial interface IAuditable
	{
		/// <summary />
		bool IsCreateAuditImplemented { get; }
		/// <summary />
		bool IsModifyAuditImplemented { get; }
		/// <summary />
		bool IsTimestampAuditImplemented { get; }

		/// <summary />
		string CreatedBy { get; }
		/// <summary />
		DateTime? CreatedDate { get; }
		/// <summary />
		string ModifiedBy { get; }
		/// <summary />
		DateTime? ModifiedDate { get; }
		/// <summary />
		byte[] TimeStamp { get; }
	}
	#endregion

	#region CustomMetadata
	/// <summary />
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Class, AllowMultiple = true)]
	public class CustomMetadata : System.Attribute
	{
		/// <summary />
		public string Key { get; set; }
		/// <summary />
		public string Value { get; set; }
	}
	#endregion

	#region EntityFieldMetadata
	/// <summary />
	[AttributeUsage(AttributeTargets.Property)]
	public partial class EntityFieldMetadata : System.Attribute
	{
		/// <summary />
		public EntityFieldMetadata(
			string name,
			int sortOrder,
			bool uiVisible,
			int maxLength,
			string mask,
			string friendlyName,
			string defaultValue,
			bool allowNull,
			string description,
			bool isComputed,
			bool isUnique,
			double min,
			double max,
			bool isPrimaryKey
		)
		{
			this.Name = name;
			this.SortOrder = sortOrder;
			this.UIVisible = uiVisible;
			this.MaxLength = maxLength;
			this.Mask = mask;
			this.FriendlyName = friendlyName;
			this.Default = defaultValue;
			this.AllowNull = allowNull;
			this.Description = description;
			this.IsComputed = isComputed;
			this.IsUnique = isUnique;
			this.Min = min;
			this.Max = max;
			this.IsPrimaryKey = isPrimaryKey;
		}

		/// <summary />
		public string Name { get; set; }
		/// <summary />
		public int SortOrder { get; set; }
		/// <summary />
		public bool UIVisible { get; set; }
		/// <summary />
		public int MaxLength { get; set; }
		/// <summary />
		public string Mask { get; set; }
		/// <summary />
		public string FriendlyName { get; set; }
		/// <summary />
		public object Default { get; set; }
		/// <summary />
		public bool AllowNull { get; set; }
		/// <summary />
		public string Description { get; set; }
		/// <summary />
		public bool IsComputed { get; set; }
		/// <summary />
		public bool IsUnique { get; set; }
		/// <summary />
		public double Min { get; set; }
		/// <summary />
		public double Max { get; set; }
		/// <summary />
		public bool IsPrimaryKey { get; set; }
	}
	#endregion

	#region EntityHistory
	/// <summary>
	/// Identities an entity class as having an audit history
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class EntityHistory : System.Attribute
	{
		/// <summary />
		public EntityHistory(System.Type auditType) { this.AuditType = auditType; }
		/// <summary />
		public System.Type AuditType { get; private set; }
	}
	#endregion

	#region EntityMetadata
	/// <summary />
	[AttributeUsage(AttributeTargets.Class)]
	public partial class EntityMetadata : System.Attribute
	{
		/// <summary />
		public EntityMetadata(
			string name,
			bool allowAuditTracking,
			bool allowCreateAudit,
			bool allowModifiedAudit,
			bool allowConcurrencyAudit,
			string description,
			bool enforcePrimaryKey,
			bool immutable,
			bool isTypeTable,
			string dbSchema
		)
		{
			this.Name = name;
			this.AllowAuditTracking = allowAuditTracking;
			this.AllowCreateAudit = allowCreateAudit;
			this.AllowModifiedAudit = allowModifiedAudit;
			this.AllowConcurrencyAudit = allowConcurrencyAudit;
			this.Description = description;
			this.EnforcePrimaryKey = enforcePrimaryKey;
			this.Immutable = immutable;
			this.IsTypeTable = isTypeTable;
			this.DBSchema = dbSchema;
		}

		/// <summary />
		public string Name { get; set; }
		/// <summary />
		public bool AllowAuditTracking { get; set; }
		/// <summary />
		public bool AllowCreateAudit { get; set; }
		/// <summary />
		public bool AllowModifiedAudit { get; set; }
		/// <summary />
		public bool AllowConcurrencyAudit { get; set; }
		/// <summary />
		public string Description { get; set; }
		/// <summary />
		public bool EnforcePrimaryKey { get; set; }
		/// <summary />
		public bool Immutable { get; set; }
		/// <summary />
		public bool IsTypeTable { get; set; }
		/// <summary />
		public string DBSchema { get; set; }
	}
	#endregion

	#region MetadataTypeAttribute

	/// <summary>
	/// Specifies the metadata class to associate with a data model class.
	/// </summary>
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
	public sealed class MetadataTypeAttribute : Attribute
	{
		/// <summary>
		/// Initializes a new instance of the System.ComponentModel.DataAnnotations.MetadataTypeAttribute
		/// </summary>
		public MetadataTypeAttribute(Type metadataClassType)
		{
			this.MetadataClassType = metadataClassType;
		}

		/// <summary>
		/// Gets the metadata class that is associated with a data-model partial class.
		/// </summary>
		public Type MetadataClassType { get; private set; }
	}

	#endregion

	#region FieldNameConstantsAttribute
	/// <summary>
	/// Identities the type of IBusinessObject for an enumeration
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class FieldNameConstantsAttribute : System.Attribute
	{
		/// <summary />
		public FieldNameConstantsAttribute(System.Type targetType) { this.TargetType = targetType; }
		/// <summary />
		public System.Type TargetType { get; private set; }
	}
	#endregion

	#region PrimaryKeyAttribute
	/// <summary>
	/// Identities the primary key of an IBusinessObject enumeration
	/// </summary>
	[AttributeUsage(AttributeTargets.Field)]
	public class PrimaryKeyAttribute : System.Attribute
	{
	}
	#endregion

	#region IContext
	/// <summary>
	/// The interface for a entity context
	/// </summary>
	public partial interface IContext
	{
		/// <summary />
		ContextStartup ContextStartup { get; }

		/// <summary>
		/// The database context
		/// </summary>
		Microsoft.EntityFrameworkCore.Infrastructure.DatabaseFacade Database { get; }

		/// <summary>
		/// The database connection string
		/// </summary>
		string ConnectionString { get; }

		/// <summary>
		/// A unique key for this object instance
		/// </summary>
		Guid InstanceKey { get; }

		/// <summary>
		/// Determines the key of the model that created this library.
		/// </summary>
		string ModelKey { get; }

		/// <summary>
		/// Determines the version of the model that created this library.
		/// </summary>
		string Version { get; }

		/// <summary>
		/// Given a field enumeration value, returns an entity enumeration value designating the source entity of the field
		/// </summary>
		Enum GetEntityFromField(Enum field);

		/// <summary>
		/// Given an entity enumeration value, returns a metadata object for the entity
		/// </summary>
		/// <param name="entity"></param>
		/// <returns></returns>
		object GetMetaData(Enum entity);

		/// <summary>
		/// Given a field enumeration value, returns the system type of the associated property
		/// </summary>
		/// <param name="field"></param>
		/// <returns></returns>
		System.Type GetFieldType(Enum field);
	}
	#endregion

	#region BaseEntity
	/// <summary>
	/// The base class for all entity objects using EF 6
	/// </summary>
	public abstract partial class BaseEntity
	{
		/// <summary>
		/// Event raised after a property is changed
		/// </summary>
		public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
		/// <summary>
		/// Event raised before a property is changed
		/// </summary>
		public event System.ComponentModel.PropertyChangingEventHandler PropertyChanging;

		/// <summary />
		protected virtual void OnPropertyChanging(System.ComponentModel.PropertyChangingEventArgs e)
		{
			if (this.PropertyChanging != null)
				this.PropertyChanging(this, e);
		}

		/// <summary />
		protected virtual void OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs e)
		{
			if (this.PropertyChanged != null)
				this.PropertyChanged(this, e);
		}
	}
	#endregion

	#region IBusinessObject
	/// <summary>
	/// An interface for writable entities
	/// </summary>
	public partial interface IBusinessObject : Acme.MultiTenant.EFDAL.IReadOnlyBusinessObject
	{
		/// <summary>
		/// Sets the value of a field
		/// </summary>
		/// <param name="field">The field to set</param>
		/// <param name="newValue">The new value to set</param>
		/// <returns></returns>
		void SetValue(Enum field, object newValue);

		/// <summary>
		/// Sets the value of a field
		/// </summary>
		/// <param name="field">The field to set</param>
		/// <param name="newValue">The new value to set</param>
		/// <param name="fixLength">Determines if the length should be truncated if too long. When false, an error will be raised if data is too large to be assigned to the field.</param>
		/// <returns></returns>
		void SetValue(Enum field, object newValue, bool fixLength);

	}
	#endregion

	#region QueryOptimizer
	/// <summary>
	/// This class can be used to optimize queries or report information about the operations
	/// </summary>
	internal partial class QueryOptimizer
	{
		/// <summary>
		/// Determines if the query use select locks
		/// </summary>
		public bool NoLocking { get; set; }

		/// <summary>
		/// Determines the total time a query took to run
		/// </summary>
		public long TotalMilliseconds { get; set; }

		/// <summary>
		/// The maximum number of rows to affect with a query. 0 is no limit.
		/// </summary>
		public int ChunkSize { get; set; }

		/// <summary>
		/// Default constructor
		/// </summary>
		public QueryOptimizer()
		{
			this.NoLocking = false;
		}

		/// <summary>
		/// Initializes a new instance of this object using the specified NoLocking property
		/// </summary>
		/// <param name="noLocking">Determines if the query use select locks</param>
		public QueryOptimizer(bool noLocking)
			: this()
		{
			this.NoLocking = noLocking;
		}
	}
	#endregion

	#region IPrimaryKey
	/// <summary />
	public partial interface IPrimaryKey
	{
		/// <summary />
		long Hash { get; }
	}

	/// <summary />
	public partial class PrimaryKey : IPrimaryKey
	{
		internal PrimaryKey(string key)
		{
			this.Hash = (long)Util.HashFast(key);
		}

		/// <summary />
		public override bool Equals(object obj)
		{
			if (obj == null) return false;
			if (!(obj is PrimaryKey)) return false;
				return (((PrimaryKey)obj).Hash == this.Hash);
		}

		/// <summary />
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		/// <summary />
		public static bool operator ==(PrimaryKey a, PrimaryKey b)
		{
			if (System.Object.ReferenceEquals(a, b))
			{
				return true;
			}
			// If one is null, but not both, return false.
			if (object.ReferenceEquals(a, null) || object.ReferenceEquals(b, null))
			{
				return false;
			}

			return a.Hash == b.Hash;
		}

		/// <summary />
		public static bool operator !=(PrimaryKey a, PrimaryKey b)
		{
			return !(a == b);
		}

		/// <summary />
		public long Hash { get; private set; }
	}
	#endregion

	/// <summary>
	/// Attribute used to decorate a concurrency field
	/// </summary>
	[System.AttributeUsage(System.AttributeTargets.Property)]
	public partial class AuditTimestampAttribute : System.Attribute
	{
	}

	/// <summary>
	/// Attribute used to decorate an Audit CreatedBy field
	/// </summary>
	[System.AttributeUsage(System.AttributeTargets.Property)]
	public partial class AuditCreatedByAttribute : System.Attribute
	{
	}

	/// <summary>
	/// Attribute used to decorate an Audit CreatedDate field
	/// </summary>
	[System.AttributeUsage(System.AttributeTargets.Property)]
	public partial class AuditCreatedDateAttribute : System.Attribute
	{
	}

	/// <summary>
	/// Attribute used to decorate an Audit ModifiedBy field
	/// </summary>
	[System.AttributeUsage(System.AttributeTargets.Property)]
	public partial class AuditModifiedByAttribute : System.Attribute
	{
	}

	/// <summary>
	/// Attribute used to decorate an Audit ModifiedDate field
	/// </summary>
	[System.AttributeUsage(System.AttributeTargets.Property)]
	public partial class AuditModifiedDateAttribute : System.Attribute
	{
	}
    /// <summary>
    /// Indicates that a table has no primary key
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false)]
    public class HasNoKeyAttribute : System.Attribute
    {
    }

    /// <summary>
    /// Indicates that a string has no set maximum length
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Property, AllowMultiple = false)]
    public class StringLengthUnboundedAttribute : System.Attribute
    {
    }

    /// <summary>
    /// Indicates that a database table is tenant based
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false)]
    public class TenantEntityAttribute : System.Attribute
    {
    }

	#region IReadOnlyBusinessObject
	/// <summary />
	public partial interface IReadOnlyBusinessObject
	{
		/// <summary>
		/// If applicable, returns the maximum number of characters the specified field can hold
		/// </summary>
		/// <param name="field"></param>
		/// <returns>If not applicable, the return value is 0</returns>
		int GetMaxLength(Enum field);

		/// <summary>
		/// Returns the primary key for this object
		/// </summary>
		IPrimaryKey PrimaryKey { get; }

		/// <summary />
		System.Type GetFieldNameConstants();

		/// <summary>
		/// Gets the value of a field specified by the enumeration
		/// </summary>
		/// <param name="field">The field from which to get the value</param>
		/// <returns></returns>
		object GetValue(Enum field);

		/// <summary>
		/// Gets the value of a field specified by the enumeration
		/// </summary>
		/// <param name="field">The field from which to get the value</param>
		/// <param name="defaultValue">The default value to return if the value is null</param>
		/// <returns></returns>
		object GetValue(Enum field, object defaultValue);

		/// <summary>
		/// Returns the system type of the specified field
		/// </summary>
		/// <param name="field"></param>
		/// <returns></returns>
		System.Type GetFieldType(Enum field);
	}
	#endregion

	#region AuditPaging
	/// <summary>
	/// 
	/// </summary>
	/// <typeparam name="T">An audit object</typeparam>
	public partial class AuditPaging<T>
	{
		/// <summary />
		public AuditPaging() { }
		/// <summary />
		public int PageOffset { get; set; }
		/// <summary />
		public int RecordsPerPage { get; set; }
		/// <summary />
		public IEnumerable<T> InnerList { get; set; }
		/// <summary />
		public int TotalRecordCount { get; set; }
	}
	#endregion

	#region AuditResult
	/// <summary>
	/// A result structure for audit records
	/// </summary>
	/// <typeparam name="T"></typeparam>
	public class AuditResult<T>
	{
		/// <summary />
		public AuditResult(T item1, T item2)
		{
			this.Item1 = item1;
			this.Item2 = item2;
		}

		/// <summary />
		public IEnumerable<IAuditResultFieldCompare> Differences { get; set; }
		/// <summary />
		public T Item1 { get; internal set; }
		/// <summary />
		public T Item2 { get; internal set; }
	}
	#endregion

	#region IAuditResultFieldCompare
		/// <summary />
	public interface IAuditResultFieldCompare
	{
		/// <summary />
		System.Enum Field { get; }
		/// <summary />
		object Value1 { get; }
		/// <summary />
		object Value2 { get; }
		/// <summary />
		System.Type DataType { get; }
	}
	#endregion

	#region AuditResultFieldCompare
	/// <summary />
	public class AuditResultFieldCompare<R, E> : IAuditResultFieldCompare
	{
		/// <summary />
		public AuditResultFieldCompare(R value1, R value2, E field, System.Type dataType)
		{
			this.Field = field;
			this.Value1 = value1;
			this.Value2 = value2;
			this.DataType = dataType;
		}

		/// <summary />
		public E Field { get; internal set; }
		/// <summary />
		public R Value1 { get; internal set; }
		/// <summary />
		public R Value2 { get; internal set; }

		/// <summary />
		public System.Type DataType { get; internal set; }

		#region IAuditResultFieldCompare

		System.Enum IAuditResultFieldCompare.Field
		{
			get { return (System.Enum)Enum.Parse(typeof(E), this.Field.ToString()); }
		}

		object IAuditResultFieldCompare.Value1
		{
			get { return this.Value1; }
		}

		object IAuditResultFieldCompare.Value2
		{
			get { return this.Value2; }
		}

		#endregion

	}
	#endregion

}

namespace Acme.MultiTenant.EFDAL.EventArguments
{
	#region ChangedEventArgs
	/// <summary>
	/// The event argument type of all property setters after the property is changed
	/// </summary>
	/// <typeparam name="T"></typeparam>
	public partial class ChangedEventArgs<T> : System.ComponentModel.PropertyChangingEventArgs
	{
		/// <summary>
		/// Initializes a new instance of the ChangingEventArgs class
		/// </summary>
		/// <param name="newValue">The new value of the property being set</param>
		/// <param name="propertyName">The name of the property being set</param>
		public ChangedEventArgs(T newValue, string propertyName)
			: base(propertyName)
		{
			this.Value = newValue;
		}
		/// <summary>
		/// The new value of the property
		/// </summary>
		public T Value { get; set; }
	}
	#endregion

	#region ChangingEventArgs
	/// <summary>
	/// The event argument type of all property setters before the property is changed
	/// </summary>
	public partial class ChangingEventArgs<T> : ChangedEventArgs<T>
	{
		/// <summary>
		/// Initializes a new instance of the ChangingEventArgs class
		/// </summary>
		/// <param name="newValue">The new value of the property being set</param>
		/// <param name="propertyName">The name of the property being set</param>
		public ChangingEventArgs(T newValue, string propertyName)
			: base(newValue, propertyName)
		{
		}
		/// <summary>
		/// Determines if this operation is cancelled.
		/// </summary>
		public bool Cancel { get; set; }
	}
	/// <summary />
	public class EntityEventArgs : System.EventArgs
	{
		/// <summary />
		public IBusinessObject Entity { get; set; }
	}
	/// <summary />
	public class EntityListEventArgs : System.EventArgs
	{
		/// <summary />
		public IEnumerable<Microsoft.EntityFrameworkCore.ChangeTracking.EntityEntry> List { get; set; }
	}
}
	#endregion

namespace Acme.MultiTenant.EFDAL.Exceptions
{
	#region ConcurrencyException
	/// <summary>
	/// Summary description for ConcurrencyException.
	/// </summary>
	public partial class ConcurrencyException : nHydrateException
	{
		/// <summary />
		public ConcurrencyException(string message)
			: base(message)
		{
		}

		/// <summary />
		public ConcurrencyException(string message, System.Exception ex)
			: base(message, ex)
		{
		}
	}
	#endregion

	#region nHydrateException
	/// <summary />
	public partial class nHydrateException : System.Exception
	{
		/// <summary />
		public string ErrorCode = null;
		/// <summary />
		public string []Arguments = null;

		/// <summary />
		public nHydrateException (): base ()
		{
		}

		/// <summary />
		public nHydrateException ( string Message ) : base ( Message )
		{
		}
		
		/// <summary />
		public nHydrateException ( string Message, System.Exception InnerException ) : base ( Message, InnerException )
		{
		}

		/// <summary />
		public nHydrateException ( string ErrorCode, string Message ) : base ( Message )
		{
			this.ErrorCode = ErrorCode;
		}

		/// <summary />
		public nHydrateException ( string ErrorCode, params object [] Arguments )
		{
			this.ErrorCode = ErrorCode;
			//this.arguments = arguments;

			this.Arguments = new string [Arguments.Length];

			for ( var length = 0; length < Arguments.Length; ++ length )
			{
				this.Arguments[length] = (string)Arguments [length];
			}
		}

		/// <summary />
		public nHydrateException ( string ErrorCode, string Message, System.Exception InnerException ) : base ( Message, InnerException )
		{
			this.ErrorCode = ErrorCode;
		}

	}
	#endregion

	#region UniqueConstraintViolatedException
	/// <summary>
	/// Summary description for UniqueConstraintViolatedException.
	/// </summary>
	public partial class UniqueConstraintViolatedException : nHydrateException
	{
		/// <summary />
		public UniqueConstraintViolatedException(string message)
			: base(message)
		{
		}
		/// <summary />
		public UniqueConstraintViolatedException(string message, System.Exception ex)
			: base(message, ex)
		{
		}
	}
	#endregion

}
