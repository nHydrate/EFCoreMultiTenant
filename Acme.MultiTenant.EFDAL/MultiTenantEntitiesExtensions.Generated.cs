//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Linq;
using System.Collections.Generic;
using Acme.MultiTenant.EFDAL.Entity;
using System.Linq.Expressions;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Query;
using Microsoft.EntityFrameworkCore.Storage;

namespace Acme.MultiTenant.EFDAL
{
	#region MultiTenantEntitiesExtensions

	/// <summary>
	/// Extension methods for this library
	/// </summary>
	[System.CodeDom.Compiler.GeneratedCode("nHydrate", "7.0.0")]
	public static partial class MultiTenantEntitiesExtensions
	{
		#region GetFieldType Extension Method

		/// <summary>
		/// Get the system type of a field of one of the contained context objects
		/// </summary>
		public static System.Type GetFieldType(this Acme.MultiTenant.EFDAL.MultiTenantEntities context, Enum field)
		{
			if (field is Acme.MultiTenant.EFDAL.Entity.Project.FieldNameConstants)
				return Acme.MultiTenant.EFDAL.Entity.Project.GetFieldType((Acme.MultiTenant.EFDAL.Entity.Project.FieldNameConstants)field);
			if (field is Acme.MultiTenant.EFDAL.Entity.ProjectFile.FieldNameConstants)
				return Acme.MultiTenant.EFDAL.Entity.ProjectFile.GetFieldType((Acme.MultiTenant.EFDAL.Entity.ProjectFile.FieldNameConstants)field);
			if (field is Acme.MultiTenant.EFDAL.Entity.ProjectType.FieldNameConstants)
				return Acme.MultiTenant.EFDAL.Entity.ProjectType.GetFieldType((Acme.MultiTenant.EFDAL.Entity.ProjectType.FieldNameConstants)field);
			if (field is Acme.MultiTenant.EFDAL.Entity.TenantMaster.FieldNameConstants)
				return Acme.MultiTenant.EFDAL.Entity.TenantMaster.GetFieldType((Acme.MultiTenant.EFDAL.Entity.TenantMaster.FieldNameConstants)field);
			if (field is Acme.MultiTenant.EFDAL.Entity.UserAccount.FieldNameConstants)
				return Acme.MultiTenant.EFDAL.Entity.UserAccount.GetFieldType((Acme.MultiTenant.EFDAL.Entity.UserAccount.FieldNameConstants)field);
			throw new Exception("Unknown field type!");
		}

		#endregion

		#region GetEntityType

		/// <summary>
		/// Determines the entity from one of its fields
		/// </summary>
		public static System.Type GetEntityType(EntityMappingConstants entityType)
		{
			switch (entityType)
			{
				case EntityMappingConstants.Project: return typeof(Acme.MultiTenant.EFDAL.Entity.Project);
				case EntityMappingConstants.ProjectFile: return typeof(Acme.MultiTenant.EFDAL.Entity.ProjectFile);
				case EntityMappingConstants.ProjectType: return typeof(Acme.MultiTenant.EFDAL.Entity.ProjectType);
				case EntityMappingConstants.TenantMaster: return typeof(Acme.MultiTenant.EFDAL.Entity.TenantMaster);
				case EntityMappingConstants.UserAccount: return typeof(Acme.MultiTenant.EFDAL.Entity.UserAccount);
			}
			throw new Exception("Unknown entity type!");
		}

		#endregion

		#region GetValue Methods

		/// <summary>
		/// Gets the value of one of this object's properties.
		/// </summary>
		/// <typeparam name="T">The type of value to retrieve</typeparam>
		/// <typeparam name="R">The type of object from which retrieve the field value</typeparam>
		/// <param name="item">The item from which to pull the value.</param>
		/// <param name="selector">The field to retrieve</param>
		/// <returns></returns>
		public static T GetValue<T, R>(this R item, System.Linq.Expressions.Expression<System.Func<R, T>> selector)
			where R : BaseEntity
		{
			var b = selector.Body.ToString();
			var arr = b.Split('.');
			if (arr.Length != 2) throw new System.Exception("Invalid selector");
			var tn = arr.Last();
			var ft = ((IReadOnlyBusinessObject)item).GetFieldNameConstants();
			var te = (System.Enum)Enum.Parse(ft, tn, true);
			return item.GetValueInternal<T, R>(field: te, defaultValue: default(T));
		}

		/// <summary>
		/// Gets the value of one of this object's properties.
		/// </summary>
		/// <typeparam name="T">The type of value to retrieve</typeparam>
		/// <typeparam name="R">The type of object from which retrieve the field value</typeparam>
		/// <param name="item">The item from which to pull the value.</param>
		/// <param name="selector">The field to retrieve</param>
		/// <param name="defaultValue">The default value to return if the specified value is NULL</param>
		/// <returns></returns>
		public static T GetValue<T, R>(this R item, System.Linq.Expressions.Expression<System.Func<R, T>> selector, T defaultValue)
			where R : BaseEntity
		{
			var b = selector.Body.ToString();
			var arr = b.Split('.');
			if (arr.Length != 2) throw new System.Exception("Invalid selector");
			var tn = arr.Last();
			var ft = ((IReadOnlyBusinessObject)item).GetFieldNameConstants();
			var te = (System.Enum)Enum.Parse(ft, tn, true);
			return item.GetValueInternal<T, R>(field: te, defaultValue: defaultValue);
		}

		/// <summary>
		/// Gets the value of one of this object's properties.
		/// </summary>
		/// <typeparam name="T">The type of value to retrieve</typeparam>
		/// <typeparam name="R">The type of object from which retrieve the field value</typeparam>
		/// <param name="item">The item from which to pull the value.</param>
		/// <param name="field">The field value to retrieve</param>
		/// <param name="defaultValue">The default value to return if the specified value is NULL</param>
		/// <returns></returns>
		private static T GetValueInternal<T, R>(this R item, System.Enum field, T defaultValue)
			where R : BaseEntity
		{
			var valid = false;
			if (typeof(T) == typeof(bool)) valid = true;
			else if (typeof(T) == typeof(byte)) valid = true;
			else if (typeof(T) == typeof(char)) valid = true;
			else if (typeof(T) == typeof(DateTime)) valid = true;
			else if (typeof(T) == typeof(decimal)) valid = true;
			else if (typeof(T) == typeof(double)) valid = true;
			else if (typeof(T) == typeof(int)) valid = true;
			else if (typeof(T) == typeof(long)) valid = true;
			else if (typeof(T) == typeof(Single)) valid = true;
			else if (typeof(T) == typeof(string)) valid = true;
			if (!valid)
				throw new Exception("Cannot convert object to type '" + typeof(T).ToString() + "'!");

			object o = ((IReadOnlyBusinessObject)item).GetValue(field, defaultValue);
			if (o == null) return defaultValue;

			if (o is T)
			{
				return (T)o;
			}
			else if (typeof(T) == typeof(bool))
			{
				return (T)(object)Convert.ToBoolean(o);
			}
			else if (typeof(T) == typeof(byte))
			{
				return (T)(object)Convert.ToByte(o);
			}
			else if (typeof(T) == typeof(char))
			{
				return (T)(object)Convert.ToChar(o);
			}
			else if (typeof(T) == typeof(DateTime))
			{
				return (T)(object)Convert.ToDateTime(o);
			}
			else if (typeof(T) == typeof(decimal))
			{
				return (T)(object)Convert.ToDecimal(o);
			}
			else if (typeof(T) == typeof(double))
			{
				return (T)(object)Convert.ToDouble(o);
			}
			else if (typeof(T) == typeof(int))
			{
				return (T)(object)Convert.ToInt32(o);
			}
			else if (typeof(T) == typeof(long))
			{
				return (T)(object)Convert.ToInt64(o);
			}
			else if (typeof(T) == typeof(Single))
			{
				return (T)(object)Convert.ToSingle(o);
			}
			else if (typeof(T) == typeof(string))
			{
				return (T)(object)Convert.ToString(o);
			}
			throw new Exception("Cannot convert object!");
		}

		#endregion

		#region SetValue
		/// <summary>
		/// Assigns a value to a field on this object.
		/// </summary>
		/// <param name="item">The entity to set</param>
		/// <param name="selector">The field on the entity to set</param>
		/// <param name="newValue">The new value to assign to the field</param>
		public static void SetValue<TResult, R>(this R item, System.Linq.Expressions.Expression<System.Func<R, TResult>> selector, TResult newValue)
			where R : BaseEntity, IBusinessObject
		{
			SetValue(item: item, selector: selector, newValue: newValue, fixLength: false);
		}

		/// <summary>
		/// Assigns a value to a field on this object.
		/// </summary>
		/// <param name="item">The entity to set</param>
		/// <param name="selector">The field on the entity to set</param>
		/// <param name="newValue">The new value to assign to the field</param>
		/// <param name="fixLength">Determines if the length should be truncated if too long. When false, an error will be raised if data is too large to be assigned to the field.</param>
		public static void SetValue<TResult, R>(this R item, System.Linq.Expressions.Expression<System.Func<R, TResult>> selector, TResult newValue, bool fixLength)
			where R : BaseEntity, IBusinessObject
		{
			var b = selector.Body.ToString();
			var arr = b.Split('.');
			if (arr.Length != 2) throw new System.Exception("Invalid selector");
			var tn = arr.Last();
			var ft = ((IReadOnlyBusinessObject)item).GetFieldNameConstants();
			var te = (System.Enum)Enum.Parse(ft, tn, true);
			((IBusinessObject)item).SetValue(field: te, newValue: newValue, fixLength: fixLength);
		}

		#endregion

		#region ObservableCollection
		/// <summary>
		/// Returns an observable collection that can bound to UI controls
		/// </summary>
		public static System.Collections.ObjectModel.ObservableCollection<T> AsObservable<T>(this System.Collections.Generic.IEnumerable<T> list)
			where T : Acme.MultiTenant.EFDAL.IReadOnlyBusinessObject
		{
			var retval = new System.Collections.ObjectModel.ObservableCollection<T>();
			foreach (var o in list)
				retval.Add(o);
			return retval;
		}
		#endregion

		#region Metadata Extension Methods

		/// <summary>
		/// Creates and returns a metadata object for an entity type
		/// </summary>
		/// <param name="entity">The source class</param>
		/// <returns>A metadata object for the entity types in this assembly</returns>
		public static Acme.MultiTenant.EFDAL.IMetadata GetMetaData(this Acme.MultiTenant.EFDAL.IReadOnlyBusinessObject entity)
		{
			var a = entity.GetType().GetTypeInfo().GetCustomAttributes(typeof(MetadataTypeAttribute), true).FirstOrDefault();
			if (a == null) return null;
			var t = ((MetadataTypeAttribute)a).MetadataClassType;
			if (t == null) return null;
			return Activator.CreateInstance(t) as Acme.MultiTenant.EFDAL.IMetadata;
		}

		#endregion

        #region Many-to-Many Convenience Extensions
        #endregion
	}

	#region SequentialIdGenerator

	/// <summary>
	/// Generates Sequential Guid values that can be used for Sql Server UniqueIdentifiers to improve performance.
	/// </summary>
	internal class SequentialIdGenerator
	{
		private readonly object _lock;
		private Guid _lastGuid;
		// 3 - the least significant byte in Guid ByteArray [for SQL Server ORDER BY clause]
		// 10 - the most significant byte in Guid ByteArray [for SQL Server ORDERY BY clause]
		private static readonly int[] SqlOrderMap = new int[] { 3, 2, 1, 0, 5, 4, 7, 6, 9, 8, 15, 14, 13, 12, 11, 10 };

		/// <summary>
		/// Creates a new SequentialId class to generate sequential GUID values.
		/// </summary>
		public SequentialIdGenerator() : this(Guid.NewGuid()) { }

		/// <summary>
		/// Creates a new SequentialId class to generate sequential GUID values.
		/// </summary>
		/// <param name="seed">Starting seed value.</param>
		/// <remarks>You can save the last generated value <see cref="LastValue"/> and then 
		/// use this as the new seed value to pick up where you left off.</remarks>
		public SequentialIdGenerator(Guid seed)
		{
			_lock = new object();
			_lastGuid = seed;
		}

		/// <summary>
		/// Last generated guid value.  If no values have been generated, this will be the seed value.
		/// </summary>
		public Guid LastValue
		{
			get {
				lock (_lock)
				{
					return _lastGuid;
				}
			}
			set
			{
				lock (_lock)
				{
					_lastGuid = value;
				}
			}
		}

		/// <summary>
		/// Generate a new sequential id.
		/// </summary>
		/// <returns>New sequential id value.</returns>
		public Guid NewId()
		{
			Guid newId;
			lock (_lock)
			{
				var guidBytes = _lastGuid.ToByteArray();
				ReorderToSqlOrder(ref guidBytes);
				newId = new Guid(guidBytes);
				_lastGuid = newId;
			}

			return newId;
		}

		private static void ReorderToSqlOrder(ref byte[] bytes)
		{
			foreach (var bytesIndex in SqlOrderMap)
			{
				bytes[bytesIndex]++;
				if (bytes[bytesIndex] != 0)
				{
					break;
				}
			}
		}

		/// <summary>
		/// IComparer.Compare compatible method to order Guid values the same way as MS Sql Server.
		/// </summary>
		/// <param name="x">The first guid to compare</param>
		/// <param name="y">The second guid to compare</param>
		/// <returns><see cref="System.Collections.IComparer.Compare"/></returns>
		public static int SqlCompare(Guid x, Guid y)
		{
			var result = 0;
			var index = SqlOrderMap.Length - 1;
			var xBytes = x.ToByteArray();
			var yBytes = y.ToByteArray();

			while (result == 0 && index >= 0)
			{
				result = xBytes[SqlOrderMap[index]].CompareTo(yBytes[SqlOrderMap[index]]);
				index--;
			}
			return result;
		}
	}

	#endregion

	#endregion

}
